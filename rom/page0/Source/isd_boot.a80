;         ORG 0X5E00
         PHASE 0X5e00
HDD_LOADER  EQU 0X6000          ;буфер для 0-го блока
HDD_BF  EQU BUFFSEC
;Перед запуском запретить прерывания!

;2 точки входа

;сканирование винчестера в поисках
;uni_boot.sys
         JP H_SCAN

;процедура чтения данных с винчестера
         JP H_READ

;системные переменные загрузчика
;после обнаружения загрузочного трека
;сюда будут перенесены данные о конфи-
;гурации винчестера
H_HEAD   DEFB 1   ;количество головок
H_SEC    DEFB 1   ;количество секторов
         DEFW 0
H_HS2    DEFW 2   ;heads*sectors*2
         DEFW 0
H_TRK    DEFW 0   ;сканируемый трек
H_SDH    DEFB 0XA0 ;маска для SDH-регистра
;занеся сюда 0XB0 можно грузиться с устрой
;ства SLAVE

;этот кусок кода принадлежал, по-видимому
;процедуре H_RES, но потом был выкинут
;и теперь не используется
         IN A,(0XF0)
         CP 0X50
         RET Z

;процедура производит программный сброс
;винчестера
H_RES    LD A,(H_SDH)
         OUT (0XD0),A   ;выбор устройства
         LD A,%0001100 ;уст. бит SRST
         OUT (0XC8),A   ;в Fixed disk reg.
         LD B,0        ;выдерживаем паузу
         DJNZ $
         LD A,%00001000 ;сбрасываем бит
         OUT (0XC8),A    ;SRST
H_RES1   IN A,(0XF0)  ;ждем готовности
         RLCA
         JR C,H_RES1
         LD A,0X10    ;команда recalibrate
         OUT (0XF0),A
H_RES2   IN A,(0XF0)   ;ждем готовности
         BIT 7,A      ;после выполнения
         JR NZ,H_RES2 ;команды
         CP 0X50   ;проверка на нормальное
         RET Z    ;завершение
         JR H_RES ;иначе все сначала

;процедура читает данные с винчестера
;Вход: B - сколько блоков читать
;      HL - куда читать
;      DE - с какого блока читать
;блоки отсчитываются от текущего трека
;в H_TRK, то есть как бы H_TRK служит
;началом устройства
;Выход: NC - О.К.
;        C - ошибка

H_READ   CALL H_CALC ;вычисляем номер трека и головки
         JR C,H_RD3  ;если читаем один блок с начала сектора
H_RD1    CALL H_CSEC ;считаем, сколько секторов на треке надо
         PUSH BC     ;прочитать и откуда читать
         CALL H_MLT  ;читаем на текущем треке нужные сектора
         POP BC
         RET C       ;если была ошибка
         LD A,B      ;проверка, надо ли еще читать сектора
         OR A
         JR Z,H_RD2  ;больше не надо
         CALL H_SET  ;переходим на следующую головки или трек
         JR H_RD1    ;повторяем
H_RD2    CALL H_CHK  ;проверка, следует ли дочитывать еще
                     ;половинку сектора
         RET Z       ;нет, не дано, выход из процедуры

;иначе дочитываем половинку сектора (256 байт)
H_RD3    LD A,E      ;номер текущего сектора
         INC A       ;нумерация секторов у веника начинается
         OUT (0X70),A ;с 1, а номер в E - с 0, поэтому увелич.
         LD A,1      ;работаем с одним сектором
         OUT (0X50),A ;заносим в счетчик секторов
         LD A,0X21    ;команда Read sector(s)
         OUT (0XF0),A
         CALL H_RDY  ;ожидаем готовности накопителя
         RET C       ;если ошибка, то выход
         LD B,0      ;256 байт
H_RD4    LD C,0X10    ;читаем 256 байт
         INI
         INC C
         INI
         JR NZ,H_RD4
H_RD5    IN A,(0X10)  ;остальные 256 байт сектора читаем
         IN A,(0XF0)  ;вхолостую
         BIT 3,A     ;пока DRQ не сбросится в 0
         JR NZ,H_RD5
         RRCA        ;бит ERR переносим в CF
         RET         ;так что если была ошибка, то будет CF

;процедура выполняет подсчет номера трека и номера головки
;Вход: DE - номер блока, с которого будем читать
;       B - сколько блоков надо прочитать
;Выход: CF - читаем 1 блок (256 байт) с начала сектора
;            E - номер сектора винчестера, с которого надо на-
;                чать чтение (нумерация с 0)
;            A - копия регистра E
;       NC - A=0XFF - или читаем четное количество боков с на-
;                     чала сектора или нечетное с середины
;                     сектора. В общем, означает то, что потом
;                     не надо будет дочитывать половинку секто
;                     ра.
;                     E - номер блока (256 байт) с начала тре-
;                         ка, с которого надо читать
;                     B - количество секторов, которые необхо-
;                         димо прочитать
;            A<>0XFF - или читаем нечетное количество блоков с
;                    начала сектора или четное с середины сек-
;                    тора, в общем означает то, что придется
;                    дочитывать еще пол-сектора потом
;                    E - номер блока (256 байт) с начала трека
;                        с которого надо читать
;                    B - количество секторов, которые надо про
;                        читать (без последней половинки)
;                    А - номер сектора, с которого начать чте-
;                        ние
;регистр HL сохраняется

H_CALC   PUSH DE       ;нам нужен номер блока
         EXX           ;остальное сохраняем
         POP DE
         LD HL,(H_HS2) ;DE/HS2=номер трека
         EX DE,HL
         XOR A
         LD B,A
         LD C,A
H_CLC1   SBC HL,DE     ;делим
         INC BC
         JR NC,H_CLC1
         DEC BC        ;номер трека от начала устройства
         ADD HL,DE     ;остаток от деления
         LD A,(H_SEC)
         RLCA
         LD E,A
         XOR A
         LD D,A        ;DE-количество секторов
H_CLC2   SBC HL,DE     ;делим остаток на кол-во секторов
         INC A
         JR NC,H_CLC2
         DEC A         ;номер головки
         ADD HL,DE
         EX DE,HL      ;E-остаток от деления (номер блока
                       ;на треке, с которого будем читать
         LD D,A
         LD HL,(H_TRK) ;суммируем трек с начальным треком
         ADD HL,BC     ;устройства
         LD A,E        ;номер блока на треке
         EX AF,AF'
         CALL H_SET1   ;заносим номер трека и головки в рег.
         EX AF,AF'
         SRL B         ;проверка кол-ва блоков на 1, заодно
                       ;делим на 2 - получаем кол-во секторов
                       ;для чтения
         LD E,A
         JR Z,H_CLC7   ;если читаем 1 блок
         JR C,H_CLC6   ;если читаем нечетное кол-во блоков
;работаем с четным количеством блоков для чтения
         RRCA          ;делим номер блока на треке на 2 и по-
                       ;лучаем номер сектора, заодно проверяем
                       ;на четность
         JR C,H_CLC4   ;нечетный блок, читаем со второй поло-
                       ;вины сектора, A<>0XFF
;читаем четное количество блоков с начала сектора
H_CLC3   LD A,0XFF       ;устанавливаем признак
H_CLC4   LD (H_CHK+1),A
H_CLC5   OR A           ;NC
         RET
;нечетное количество блоков
H_CLC6   RRCA          ;делим номер блока на треке на 2 и полу
                       ;чаем номер сектора, заодно проверяем
                       ;на четность
         JR NC,H_CLC4  ;читаем с начала сектора, A<>0XFF
         INC B         ;целое количество секторов, которые
                       ;надо прочитать
         JR H_CLC3     ;A=0XFF

;если читаем 1 блок
H_CLC7   INC B       ;после деления B=0, поэтому увеличиваем
                     ;до 1 - сколько секторов надо читать
         RRCA        ;делим номер блока на треке на 2 и полу-
                     ;чаем номер сектора
         JR C,H_CLC3 ;если с середины сектора
;тут читаем один блок с начала сектора
         LD E,A      ;номер сектора
         SCF         ;CF
         RET

;процедура опредляет, откуда читать очередной блок - с начала
;сектора или с его второй половины. Также определяет сколько
;еще секторов нужно прочитать до конца этого трека
;Вход: Е - номер блока на треке, с которого надо читать
;      В - сколько секторов надо прочитать
;Выход: CF - начинать чтение со второй половины сектора
;       NC - с начала сектора
;       А - номер сектора, с которого начинать чтение
;       Е - сколько секторов на треке еще осталось дочитать
;       В - сколько секторов останется прочитать после этого
;           трека
;Дело в том, что файл читается блоками по несколько секторов
;в пределах трека. Вот процедура и считает, исходя из длины
;файла сколько секторов на треке еще можно прочитать и сколько
;останется на потом

H_CSEC   SRL E        ;номер сектора, с которого читать
                      ;если с начала, то NC, иначе - C
         LD A,E
         PUSH AF      ;сохраняем флаги
         LD A,(H_SEC) ;кол-во секторов на трек
         SUB E        ;сколько осталось на треке для чтения
         LD E,A
         LD A,B       ;сколько надо прочитать
         SUB E        ;склько останется за пределами трека
         JR NC,H_CS1  ;если читать надо больше, чем осталось
                      ;на треке
;в этом случае все сектора, которые нам надо, находятся на
;текущем треке
         XOR A  ;за пределами трека ничего не надо читать (0)
         LD E,B ;сколько надо прочитать
H_CS1    LD B,A ;сколько прочитать за пределами трека
         POP AF ;восстанавливаем флаги
         RET

;процедура переходит на следующий номер головки или трека
;(в том случае, если на текущем уже все прочитано)
;Вход: D' - текущий номер головки
;      HL' - номер трека

H_SET    LD E,0 ;через Е передается номер блока на треке,
                ;а так как на треке все блоки прочитаны,
                ;то нумерация начинается с 0
         EXX
         INC D         ;следующая головка
         LD A,(H_HEAD)
         CP D          ;все ли головки перебрали?
         JR NZ,H_SET1  ;еще не все
         LD D,0        ;головка 0
         INC HL        ;увеличиваем номер трека
H_SET1   IN A,(0XF0)    ;ожидаем готовности накопителя
         CP 0X50
         JR NZ,H_SET1
         LD A,L        ;заносим в регистры винчестера номера
         OUT (0X90),A   ;трека и головки
         LD A,H
         OUT (0XB0),A
         LD A,(H_SDH)
         OR D
         OUT (0XD0),A
         EXX
         RET

;проверяет, надо ли в конце файла читать только полсектора, а
;вторую половину пропустить
;Выход: Z - не надо ничего дочитывать
;       NZ - надо дочитать полсектора, при этом процедура сама
;переходит на тот сектор, который надо дочитать
H_CHK    LD A,0       ;сюда записывается признак того, надо
                      ;ли дочитывать пол-сектора
         CP 0XFF       ;если 0XFF, то не надо
         RET Z
         IN A,(0X70)   ;текущий сектор
         LD E,A
         LD A,(H_SEC) ;кол-во секторов на треке
         CP E         ;последний сектор?
         JR Z,H_SET   ;если да, то переходим на следующий
                      ;сектор с помощью H_SET
         RET

;загружает E блоков на текущем треке
;Вход: A - с какого сектора грузить (нумерация с 0)
;      E - сколько секторов грузить (если у последнего сектора
;надо грузить половинку, то он не считается)
;      HL - адрес загрузки
;      NC - читать с начала сектора
;      CF - с середины сектора
;Выход: CF - ошибка чтения

H_MLT    PUSH AF     ;сохраняем CF
         INC A       ;номер сектора на 1 (нумерация теперь с 1)
         OUT (0X70),A ;Sector number
         POP AF
         LD A,E      ;сколько секторов читаем
         OUT (0X50),A ;Sector counter
         LD A,0X21     ;команда Read sector(s)
         OUT (0XF0),A
         JR NC,H_MLT3 ;если читаем с начала
;пропускаем 256 байт
         CALL H_RDY   ;ждем готовности
         RET C
         LD B,0X80     ;128*2=256 байт
H_MLT1   IN A,(0X10)   ;одно чтение 0X10 равносильно 2-м байтам
         DJNZ H_MLT1
;читаем 256 байт второй половинки сектора
;после предыдущего кода В=0, т.е. 256 байт
H_MLT2   LD C,0X10
         INI
         INC C
         INI
         JR NZ,H_MLT2
         IN A,(0X50)  ;читаем пока счетчик секторов не
         OR A        ;обнулится
         RET Z

;чтение полного сектора - 512 байт
H_MLT3   CALL H_RDY  ;ожидаем готовности
         RET C
         LD C,0X10
H_MLT4   INI
         INC C
         INI
         DEC C
         IN A,(0XF0)
         BIT 3,A
         JR NZ,H_MLT4
         IN A,(0X50)    ;пока не обнулится счетчик секторов
         OR A
         JR NZ,H_MLT3
         RET

;процедура ожидает готовности винчестера. В случае ошибки
;возвращается с флагом C и кодом ошибки в А.
H_RDY    IN A,(0XF0)
         BIT 7,A     ;BSY
         JR NZ,H_RDY
         BIT 3,A     ;DRQ
         JR Z,H_RDY
         RRCA        ;ERR -> CF
         RET NC
         CALL H_RES  ;делаем сброс
         LD A,7      ;код ошибки - 7
         SCF
         RET

;сканирование винчестера с поиском загрузочного трека
;сканируются треки 0-255. В случае обнаружения загрузочного
;трека процедура запустит на выполнение uni_boot.sys. Если все
;треки перебраны, компьютер просто зависнет.

H_SCAN   ;LD SP,0X5DC0
;назначение этого вывова мне непонятна, лучше тут поставить
;CALL H_RES для нормальной загрузки если винчестер перед этим
;заглючил
         CALL H_CLC5

H_SCN1   LD A,1         ;начинаем с синего цвета бордюра, так
         OUT (0XFE),A    ;как, как правило, загрузочным треком
;являтся нулевой, а система имеет синий бордюр (тоже как пра-
;вило)
         CALL H_ANL     ;загрузка трека в память и его анализ
;если процедура отдала управление обратно, то этот трек не
;является загрузочным
         LD HL,H_SCN1+1 ;меняем цвет бордюра
         INC (HL)
         LD HL,H_TRK    ;следующий трек
         INC (HL)
         JR NZ,H_SCN1   ;если не перебрали 256 треков, то
;возвращаемся и анализируем следующий
         SCF
         RET
;         HALT           ;так как перед вызовом загрузчика
;прерывание были запрещены, то зависаем

;процедура анализирует трек с номером в H_TRK
;если он загрузочный, то запускается uni_boot.sys
H_ANL    LD HL,HDD_BF       ;загружаем 0-й блок трека
         LD B,1
         LD DE,0
         CALL H_READ
         JR C,H_NONE
         LD HL,(HDD_BF+0X7D) ;проверка на наличие "KAY"
         LD DE,0X414B        ;по смещению 0X7D
         LD A,(HDD_BF+0X7F)
         XOR 0X59
         JR NZ,H_NONE             ;не то
         SBC HL,DE
         JR NZ,H_NONE             ;не то
         LD HL,(HDD_BF+97)  ;переносим инфу о венике
         LD A,L             ;в системные переменные
         OR H               ;загрузчика
         JR Z,H_NONE              ;проверяем HEAD и SEC на 0
         LD (H_HEAD),HL     ;если там 0, то что-то не так
         LD HL,(HDD_BF+115) ;HEAD*SEC*2
         LD A,L
         OR H
         JR Z,H_NONE
         LD (H_HS2),HL
         LD DE,(HDD_BF+0X80+17) ;номер блока, где расположен
         LD A,E             ;uni_boot.sys
         OR D               ;проверка на 0
         JR Z,H_NONE
         LD HL,(HDD_BF+0X80+12) ;адрес загрузки
         LD A,L             ;проверка на 0
         OR H
         JR Z,H_NONE
         LD A,(HDD_BF+0X80+15) ;размер файла в блоках
         OR A               ;проверка на 0
         JR Z,H_NONE
         INC A
         LD B,A
         PUSH HL           ;сохраняем стартовый адрес с стеке
         EXX
         LD HL,HDD_BF
         LD DE,HDD_LOADER
         LD BC,512
         LDIR
         EXX
         CALL H_READ       ;читаем uni_boot.sys
         JR NC,H_NONE            ;если О.К. то запуск
         POP HL            ;иначе выход
H_NONE
         SCF
         RET
         DEPHASE